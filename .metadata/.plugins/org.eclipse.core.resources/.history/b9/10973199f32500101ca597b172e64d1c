/****************************************************************************
FileName:
Dependencies:
Processor:
Hardware:
Complier:
Company:      InVue


 Author       Date      Comment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Nick McKendree    7/2017
kburtness     Original - S960
*****************************************************************************
General description:

IR Key Application Level Functions



usage:

***************************************************************************
***************************** NOTE ****************************************
***************************************************************************

****************************************************************************
                            INCLUDES
****************************************************************************/
#include <stdint.h>
#include <stdbool.h>

#include "em_device.h"
#include "em_eusart.h"
#include "sl_udelay.h"

#include "app.h"
#include "appGPIO.h"
#include "ir_comms_product_list.h"
#include "invue_ir_comms.h"
#include "invue_ir_key_app.h"
#include "cyclic_fifo_queue.h"
#include "app_version.h"
#include "app_ir_uart_hal.h"
#include "data.h"
#include "Utils.h"
#include "debugPrint.h"
#include "security.h"
#include "motorGlue.h"
#include "special_features.h"
#include "msgHandler.h" // needed for definition of NEVER_BEEN_ENROLLED

/****************************************************************************
                            TYPEDEFS
****************************************************************************/
typedef enum{
    RTD_IR_TEST_KEY,           // 0
    RTD_IR_VALID_KEY,          // 1
    RTD_IR_INVALID_KEY,        // 2
    RTD_IR_MAGIC_KEY,          // 3
    RTD_IR_CODE_READER,        // 4
    RTD_IR_HOUSE_KEY,          // 5
} _eirKeyType;

/****************************************************************************
                            DEFINES
****************************************************************************/
#define PROD_ID_PRODUCT_LINE                    PRODUCT_LINE_SMT_LOCK
#define IR_IDLE_INACTIVE_TIME_MS                20
#define KEYPRESS_ACCUMULATE_PRESSES_TIMEOUT_MS  10000        // increased to 10 seconds to allow for 5 key presses
#define IDLE_TIME_BETWEEN_KEY_PRESSES_MS        375     // Was 600 but recorded as low as 440mS with IR2 Keys

#define IR_DIAGNOSTIC_RDR_TIMEOUT_MS            5000
#define WIRELESS_TEST_RETRY_TIMEOUT_MS      10000 // Extended to 15s if supporting the iperf test
#define RETRY_TIMEOUT_MS                        1000
#define IR_MTP_RETRY_CNT                        3
#define TURNAROUND_RESPONSE_DELAY               100     // About 20 byte times @ 6553
#define MAGIC_KEY_RESET_WAIT_PERIOD_MS      5000
#define NUM_OF_PRESSES_BEFORE_THE_REMERCHANDISE_PRESS 2
#if DIAG_RDR_REV == 2
#define DIAGNOSTIC_RDR_LEN  52
#else
#define DIAGNOSTIC_RDR_LEN  46
#endif

#define IR_SPECIAL_CMD_PKT_LEN          7
#define IR_SPECIAL_CMD_ID           0x21
#define IR_SPECIAL_CMD_SET_TEST_MODE      0x01
#define IR_SPECIAL_CMD_FACTORY_RESET      0x02
#define IR_SPECIAL_CMD_RESET_PROVISIONING   0x03
#define IR_SPECIAL_CMD_SET_MODE         0x04
#define IR_SPECIAL_CMD_CRC_MSB          4
#define IR_SPECIAL_CMD_CRC_LSB          5
#define HW_MODEL_MASK             0xE0    // Preserve 3 bits for HW variation
#define HW_MODEL_BIT_SHIFT            5
#define mSetHWModel(x,in)           ( (in & ~HW_MODEL_MASK) | x << HW_MODEL_BIT_SHIFT )
#define HW_REV_MASK               0x1F    // Preserve 5 bits for HW version
#define HW_REV_BIT_SHIFT            0
#define MSetHWRev(x,in)             ( (in & ~HW_REV_MASK) | x << HW_REV_BIT_SHIFT )
#define IR_BAUDRATE               6553

#define IR4_SERIAL_LENGTH           6

#define IR_LOOPBACK_LOOP_CNT          10
#define IR_LOOPBACK_SIGNAL_DWELL_CNT      200
#define IR_LOOPBACK_PASS_CNT          ( ( IR_LOOPBACK_SIGNAL_DWELL_CNT * IR_LOOPBACK_LOOP_CNT) - ( ( IR_LOOPBACK_SIGNAL_DWELL_CNT * IR_LOOPBACK_LOOP_CNT) >> 2))      // Passing is 75% of max count

#define BACKDOOR_TIMEOUT_MS           mTIME_TO_MS( 0/*hr*/, 0/*min*/, 20/*sec*/ )

#define REGULAR_PRESS_TIMEOUT_MS  8000

// I was told at the last minute that ELT & ARB do NOT want Unconnected Keys to 
// EVER work with mKey, but I'm betting some customer is going to want it, so 
// we can add it back in by setting this from 0 to 1.
#define ALLOW_UNCONNECTED_IR_KEYS_WITH_MKEY 0



/****************************************************************************
                            FUNCTION PROTOTYPES
****************************************************************************/

void ir_send_packet( void );
void magicKeyCB(invue_ir_mode_enum ir_mode);
static void get_IR4_info(IR4_LockStatus_e *ir4_lockState, IR4_DeviceState *ir4_status);


/****************************************************************************
                            VARIABLES
****************************************************************************/
volatile uint32_t ir_inactive_tmr = 0;
uint32_t blank_key_timer_ms = 0;
extern volatile uint32_t are_there_more_ir_bytes_to_send;
uint32_t temperature_for_codeReader = 0;
static /*volatile*/ uint8_t ir_key_rx_buffer[ IR_MSG_MAX_LENGTH + 1 ];				// IR msg length + 1 as requested in cyclic header file.
static /*volatile*/ uint8_t ir_key_tx_buffer[ 256 + 1 ];				// IR msg length + 1 as requested in cyclic header file.
static /*volatile*/ cyclic_fifo_queue_struct rx_queue = {
                         0,
                         0,
                         0,
                         0,
                         sizeof(ir_key_rx_buffer[0]),
                         (unsigned int)(sizeof(ir_key_rx_buffer) / sizeof(ir_key_rx_buffer[0])) - 1,
                         ir_key_rx_buffer
                       };
static /*volatile*/ cyclic_fifo_queue_struct tx_queue = {
                         0,
                         0,
                         0,
                         0,
                         sizeof(ir_key_tx_buffer[0]),
                         (unsigned int)(sizeof(ir_key_tx_buffer) / sizeof(ir_key_tx_buffer[0])) - 1,
                         ir_key_tx_buffer
                       };
//static uint8_t validKeyPresses = 0;
//static uint32_t keyPressTimeoutTmr = KEYPRESS_ACCUMULATE_PRESSES_TIMEOUT_MS;
static uint8_t magicKeyDetected = 0;
uint32_t bootedFromIR = false;

// There are multiple consumers of this data, but the consumer destroys the 
// data upon read, therefore we need one variable per consumer, hence this array.
#if (1 == SPECIAL_FEATURES_ACTIVE)
bool latched_is_valid_ir_key_transaction[IR_DATA_LAST_RECIPIENT_ID+1] = { 0 };
#else
static bool latched_is_valid_ir_key_transaction[IR_DATA_LAST_RECIPIENT_ID+1] = { 0 };
#endif

static _ir_comms_ctx_s ir_ctx =
{
    .product_id_product_line = PRODUCT_LINE_SMT_LOCK,
    .product_id_product_num = PRODUCT_LINE_SMT_PERFECT_POD,
    .ir_mode = IR4_NON_LIVE_ACCESS_MODE, // will be overwritten by contents of nv memory
    .legacy_device_type = G4DS_ALARM_UNIT,
    .sdc = { 0 }, // will be overwritten by contents of nv memory
    .my_sn = { 0 }, // will be overwritten by contents of nv memory
    .IR4_8byte_SN = false,
    .device_chirps = 1,
    .waiting_for_TOKEN_CT_WIPE_timeout_msec = 0, // unused in this F1880 product
    .legacy_code_reader_data = { 0 }, // unused in this F1880 product
    .ir4_data = { .IR4_TwoKeyStatus = Ir4TwoKeyNotActive, .IR4_key1_userid = { 0 }, .IR4_key2_userid = { 0 }, .IR4_key1_timeout = 0 },
    .R_n_D_Key_supported = false, // will be overwritten by contents of nv memory
    .ct_wipe_supported = false,
    .is_my_sn_blank = false, // will be overwritten by contents of nv memory
    .allow_IR_upgrade = true, // unused in this F1880 product because we're always in one of the IR4 modes
    ._buffers = { .rx_buffer = { 0 }, .tx_buffer = { 0 } },
    ._priv_comm_vars = { 0 },
    .callbacks = { .fill_in_IR3_blob = (size_t (*)(uint8_t[], size_t))0,
                   .get_IR3_Pod_Status = (IR3_pod_status_e (*)(void))0,
                   .get_IR3_FW_Version = (void (*)(uint8_t*))0,
                   .get_IR2_info = (void (*)(IR2_LockResults_e*, IR2_Status_e*))0,
                   .get_IR4_info = get_IR4_info,
                   .get_legacy_code_reader_data = (void (*)(uint8_t*, size_t))0,
                   .smartRetail_reject_tout_tst_key_function = (void (*)(invue_ir_mode_enum))0,
                   .smartRetail_reject_nonmatch_key_function = (void (*)(invue_ir_mode_enum))0,
                   .magicKey_cb = (void (*)(void))0
                 }
};

/****************************************************************************
                            CODE
****************************************************************************/

static void get_IR4_info(IR4_LockStatus_e *ir4_lockState, IR4_DeviceState *ir4_status)
{
    if(!getButton()) // button pulled to ground when pressed, hence the !
    {
        *ir4_lockState = areBothLimitSwitchesPressed() ? IR4_LOCK_OPENED_TO_BRACKET_REMOVAL_POSITION_SELF_LATCH : IR4_LOCK_OPENED_FULLY_SELF_LATCH;
    }
    else
    {
        *ir4_lockState = IR4_LOCK_UNLOCK_SELF_LATCH;
    }

    *ir4_status = IR4_DeviceOk;
}

/*********************************************************************
Function:
Input:          void
Output:         void
Dependencies:
Description:
********************************************************************/
void init_irAppHandler( void )
{
    const uint8_t blank_sn[DEVICE_SN_BYTES] = { 0 };

    ir_ctx.ir_mode = nvdata_get_u8_value(NVDATA8_IR_MODE);
    (void)memcpy(&ir_ctx.sdc[0],   get_sdc_pointer(),           sizeof(ir_ctx.sdc));
    (void)memcpy(&ir_ctx.my_sn[0], &get_serial_number_pointer()[2/*skip first 2 bytes*/], IR4_SERIAL_LENGTH);
    ir_ctx.is_my_sn_blank = !memcmp(&ir_ctx.my_sn[0], &blank_sn[0], IR4_SERIAL_LENGTH);
    ir_ctx.R_n_D_Key_supported = (NEVER_BEEN_ENROLLED == nvdata_get_u8_value(NVDATA8_ENROLLED_STATUS)); // if we are or have EVER been enrolled in the App, disallow R&D Keys
}

/*********************************************************************
Function:
Input:          void
Output:         void
Dependencies:
Description:
********************************************************************/
void IR_DataByte_Received( uint8_t byte )
{
  /* Set transmission flag: transfer complete*/
  cyclic_fifo_queue_add_item(&rx_queue, &byte);
}

//****************************************************************
//  bool invue_is_ir_key_tx_idle(void)
//
//  Description: Returns TRUE if the IR byte handler is waiting for byte 0
//
//****************************************************************
uint32_t invue_is_ir_key_tx_idle(void)
{
  return  ((cyclic_fifo_queue_slots_used(&tx_queue) == 0) &&          // there are no bytes to transmit
       (is_ir_TX_Enabled()     == false));                // AND the transmitter is not enabled
}

//****************************************************************
//  bool invue_is_ir_key_rx_idle(void)
//
//  Description: Returns TRUE if the IR byte handler is waiting for byte 0
//
//****************************************************************
uint32_t invue_is_ir_key_rx_idle(void)
{
  return ((irComms_is_msg_parsing_idle(&ir_ctx)       != false) &&     // we are not receiving a packet
      (cyclic_fifo_queue_slots_used(&rx_queue) == 0)     &&     // AND there are no bytes waiting in the buffer
      (is_ir_RX_Enabled()     == true));                // AND RX enabled
}

//****************************************************************
//  bool is_ir_comms_idle(void)
//
//  Description:
//
//****************************************************************
bool is_ir_comms_idle( void )
{
  return (invue_is_ir_key_rx_idle() && invue_is_ir_key_tx_idle() );
}

void magicKeyCB(invue_ir_mode_enum ir_mode)
{
  (void)ir_mode;
  magicKeyDetected = 1;
}

/*********************************************************************
Function:       processKeyInteraction
Input:          uint32_t ms_since_called
Output:         void
Dependencies:
Description:
********************************************************************/
void processKeyInteraction( uint32_t ms_since_called )
{
  (void)ms_since_called; // use to avoid compiler warning about not using

	/***********************************************************************************
	*  Process any key interaction
	**********************************************************************************/
	if ( irComms_was_magic_key_received() || magicKeyDetected) // TODO: do we need both of these?
	{
		magicKeyDetected = 0;
		irComms_reset_sdc_received();

		// tell nv memory code to also erase the SDC
		reset_sdc();

		if(NEVER_BEEN_ENROLLED != nvdata_get_u8_value(NVDATA8_ENROLLED_STATUS))
		{
			nvdata_set_u8_value(NVDATA8_ENROLLED_STATUS, NOT_ENROLLED_BUT_HAS_BEEN);
		}

		diff_and_write_nv_data();
		init_irAppHandler(); // the above lines change nvmemory, but this call sucks those changes into the ir key context struct

		// For magic key, stop reporting busy here since motor drive never runs
		IR_COMMS_DBG_PRINT_INFO(( "MK Keypress Registered\r\n "));
	}
    else
    {
        if(irComms_was_valid_sdc_received())
        {
            for(enum ir_key_data_recipient_id i = IR_DATA_FIRST_RECIPIENT_ID; i <= IR_DATA_LAST_RECIPIENT_ID; i++)
            {
                if(false == latched_is_valid_ir_key_transaction[i])
                {
                    latched_is_valid_ir_key_transaction[i] = true;
                }
            }
        }
    }
}

//****************************************************************
//  void invue_ir_key_handler_app(void)
//
//  Description: Application level IR key Comms handler.
//
//****************************************************************
void invue_ir_key_handler_app(void)
{
  uint8_t received_byte              = 0;
  uint8_t byte_available_flag        = 0;
  uint32_t tx_msg_length             = 0;
  uint32_t msec_since_last_rx;
  static uint32_t last_rx_msec                = 0;
  static uint32_t timeSince_last_keypress = 0;
  //uint8_t mtpCMDinProgress = 0;

  uint8_t serialForIR2_Comms[IR4_SERIAL_LENGTH];


  if(0 != nvdata_get_u8_value(NVDATA8_IS_IR_KEY_INTERFACE_DISABLED))
  {
      return;  // IR Keys were disabled via Bluetooth Command, so skip everything
  }


  if (0 == cyclic_fifo_queue_get_item(&rx_queue, &received_byte) )    // check if a byte is available
  {
    byte_available_flag = 1;
    last_rx_msec = scheduler_getTick();                 // save the last time a byte was received
    ir_inactive_tmr = scheduler_getTick();                // Reset the inactive timer
  }

  // calculate the time since the last byte was received
  msec_since_last_rx = scheduler_timeSince(last_rx_msec);
  if( is_ir_UART_Enabled() )
  {
    _ir_comms_output_s output;

    if (is_ir_RX_Enabled())                         // if the receiver is presently enabled
    {
      /// call the byte handler; if the byte handler indicates a complete message is available
      if (1 == irComms_get_ir_key_packet(&ir_ctx, byte_available_flag ? 0 : msec_since_last_rx, byte_available_flag, received_byte))
      {
        // IR2 Comms requires 6 bytes for the serial number where the standard IR1/IR3 module expects 8 bytes. The Bluetooth is using 8 bytes as well so we
        //   need to offset the stored serial number by 2 bytes so it is passed correctly.
        memcpy(serialForIR2_Comms, get_serial_number_pointer() + 2, IR4_SERIAL_LENGTH);

        /// handle the IR key message
        tx_msg_length = irComms_handle_ir_key_message(&ir_ctx, &output);

        /// if the RTL flag has been received
        if (1 == output.rtl_received)
        {
          /// start a timer for unauthorized keys; set the timeout to be very long to ensure
          /// time is allowed to receive a valid key prior to indicating an unauthorized key has been accepted
          blank_key_timer_ms = scheduler_getTick();

          // On RTL reception, swap the IR2 status to busy. The status response will always go out to the key before the motor driver start which updates the status.
        }
      }

      // if there is data to transmit
      if (tx_msg_length > 0)
      {
        /* disable the UART Rx */
        disable_ir_receiver();

        /* since the receiver may be active for a full byte width, we need to switch the Rx function over to
         * a digital input so we don't contaminate the Rx buffer */
        set_ir_rx_2_disabled();

        /* if the Tx line is not configured for the ALT function */
        set_ir_tx_2_UART();

        /* enable IR key UART transmitter */
        enable_ir_transmitter();

        sl_udelay_wait(1500);       // Give time to establish front porch

        /* transmit the packet */
        uint32_t i = 0;
        do
        {
          cyclic_fifo_queue_add_item(&tx_queue, &ir_ctx._buffers.tx_buffer[i]);
          i++;
        }while(--tx_msg_length);
        ir_send_packet();
      }
    }



  //  /* as a precaution, make sure either the transmitter is enabled, the receiver is enabled
    if ((!is_ir_RX_Enabled()) && (!is_ir_TX_Enabled()))/*  && (!(SIM->SCGC6 & SIM_SCGC6_TPM2_MASK)))*/
    {
      /* otherwise, enable the UART receiver */
      enable_ir_receiver();

      /* if the Rx line is not configured for the ALT function */
      set_ir_rx_2_UART();
    }

    if(irComms_valid_sdc_waiting())
    {
        bool has_any_data_changed = false; // might get set to true further down

        if(output.data_changed.sdc)
        {
            set_sdc_in_ram(&ir_ctx.sdc[0], 3/*length of sdc*/);
            has_any_data_changed = true;
        }

        if(output.data_changed.serialNum)
        {
            uint8_t serial_number[DEVICE_SN_BYTES] = { 0 };

            (void)memcpy(&serial_number[2/*leave first 2 bytes as zero*/], &ir_ctx.my_sn[0], IR4_SERIAL_LENGTH);
            set_serial_number(&serial_number[0]);
            has_any_data_changed = true;
        }

        if(output.data_changed.irMode)
        {
            nvdata_set_u8_value(NVDATA8_IR_MODE, ir_ctx.ir_mode);
            has_any_data_changed = true;
        }

        if(has_any_data_changed)
        {
            diff_and_write_nv_data();
        }
    }

    processKeyInteraction( scheduler_timeSince(timeSince_last_keypress) );
    timeSince_last_keypress = scheduler_getTick();
  }
}


/*********************************************************************
Function:
Input:          void
Output:         void
Dependencies:
Description:
********************************************************************/
uint8_t ir_app_is_valid_ir_transaction_and_clear_if_so(enum ir_key_data_recipient_id recipient_id)
{
    if(false != latched_is_valid_ir_key_transaction[recipient_id])
    {
        latched_is_valid_ir_key_transaction[recipient_id] = false;
        return 1; // as in, one IR Key Button Press, that is, a Normal Open command
    }

    return 0; // as in, zero IR Key Button Presses
}

/*********************************************************************
Function:
Input:          void
Output:         void
Dependencies:
Description:
********************************************************************/
void ir_send_packet( void )
{
  uint8_t byte;

  if (0 == cyclic_fifo_queue_get_item(&tx_queue, &byte) )
  {
    IR_transmitByte( byte );
    if( cyclic_fifo_queue_slots_used( &tx_queue ) != 0 )
    {
      are_there_more_ir_bytes_to_send = 1;
    }
  }
}

/*********************************************************************
Function:
Input:          void
Output:         void
Dependencies:
Description:
********************************************************************/
void IR_TX_Complete( void )
{
  ir_send_packet();
}

/*********************************************************************
Function:
Input:          void
Output:         void
Dependencies:
Description: Call this (likely from the Bluetooth code) any time we switch
             between being enrolled and not enrolled, because the IR Key code
             needs to disable R&D Keys if we're enrolled, and some other related stuff.
             Assumes the new enrollment value is already written to non-volatil memory!
********************************************************************/
void ir_call_if_enrollment_status_changes_in_nvmem(void)
{
#if (1 == ALLOW_UNCONNECTED_IR_KEYS_WITH_MKEY)
    // If we have a blank SDC and we are enrolled...
    if(SDC_IsItZero() && (CURRENTLY_ENROLLED == nvdata_get_u8_value(NVDATA8_ENROLLED_STATUS)))
#else
    // If we are enrolled...
    if(CURRENTLY_ENROLLED == nvdata_get_u8_value(NVDATA8_ENROLLED_STATUS))
#endif
    {
        // ...then upgrade to Connected Mode so nobody can use a random IR Key 
        // (neither authorized nor Test) as a backdoor.

#if (1 == ALLOW_UNCONNECTED_IR_KEYS_WITH_MKEY)
        // If you want to use a non-connected IR Key AND you want to be 
        // enrolled, you'll have to introduce the SDC from your non-connected 
        // IR Key FIRST.  Otherwise, if you enrolled first, then the product 
        // will refuse to take your non-connected IR Key's SDC (it WILL take a 
        // CONNECTED Key's SDC though, which isn't considered as bad a security 
        // hole, because the product's serial# will need to be in the user's 
        // authorization list).
#endif
        nvdata_set_u8_value(NVDATA8_IR_MODE, IR4_LIVE_ACCESS_MODE);
    }

    init_irAppHandler();
}

