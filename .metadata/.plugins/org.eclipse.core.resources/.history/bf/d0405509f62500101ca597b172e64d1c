/****************************************************************************
FileName:
Dependencies:
Processor:
Hardware:
Complier:
Company:      InVue


 Author				Date			Comment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Nick McKendree		7/2017
kburtness			Original - S960
*****************************************************************************
General description:

IR Key Application Level Functions



usage:

***************************************************************************
***************************** NOTE ****************************************
***************************************************************************
IR2 Keys will not work. 1 IR2 key required between 1.5 and 2 mS delay between
bytes on responses. The tested delays were 1ms, 1.5ms, and 2ms.
In order to support IR2 key or IR2 magic key, a blocking delay has to be added
to the lpuart tx interrupt of 2mS per byte (ouch).
IR2 keys are end of life and will not be sold to Amazon, and IR3 magic keys
will be a real thing in the next 3 months or so (Mike can make one).

****************************************************************************
                            INCLUDES
****************************************************************************/
#include <stdint.h>
#include <stdbool.h>

#include "em_device.h"
#include "em_eusart.h"
#include "em_cmu.h"

#include "appGPIO.h"
#include "invue_ir_key_app.h"
#include "cyclic_fifo_queue.h"
#include "app_version.h"

/****************************************************************************
                            TYPEDEFS
****************************************************************************/

/****************************************************************************
                            DEFINES
****************************************************************************/
#define IR_BAUDRATE								6553

/****************************************************************************
                            GLOBAL VARIABLES
****************************************************************************/
volatile uint32_t are_there_more_ir_bytes_to_send = 0;
static volatile uint32_t ir_uart_deinit = true;

/****************************************************************************
                            FUNCTION PROTOTYPES
****************************************************************************/
void disable_ir_transmitter(void);

/****************************************************************************
 Adding in HW specific functions for the EUART0 peripheral
****************************************************************************/
/*********************************************************************
Function:       init_ir_uart
Input:          void
Output:         void
Dependencies:
Description:
********************************************************************/
void init_ir_uart(void)
{
	// Enable EUART0 Clock
	CMU_ClockSelectSet(cmuClock_EUART0, cmuSelect_EM23GRPACLK);
    CMU_ClockEnable(cmuClock_EM23GRPACLK, true);
	CMU_ClockEnable(cmuClock_EUART0, true);

	// Initialize the EUART0 module
	EUSART_UartInit_TypeDef init = EUSART_UART_INIT_DEFAULT_LF;
	init.baudrate = IR_BAUDRATE;
	/* For this applications, keep both rx and tx enabled and use the rxblock and tx tristate features*/
	init.enable = eusartEnableRx | eusartEnableTx;

	EUSART_UartInitLf(EUART0, &init);
	EUSART_IntClear(EUART0, EUSART_IEN_RXFLIEN);
	EUSART_IntEnable(EUART0, EUSART_IEN_RXFLIEN);

	// Enable NVIC USART sources
	NVIC_ClearPendingIRQ(EUART0_RX_IRQn);
	NVIC_EnableIRQ(EUART0_RX_IRQn);
	NVIC_ClearPendingIRQ(EUART0_TX_IRQn);
	NVIC_EnableIRQ(EUART0_TX_IRQn);
	ir_uart_deinit = false;

	disable_ir_transmitter();
}

/*********************************************************************
Function:       deinit_ir_uart
Input:          void
Output:         void
Dependencies:
Description:
********************************************************************/
void deinit_ir_uart(void)
{
	EUSART_Reset(EUART0);
	NVIC_ClearPendingIRQ(EUART0_RX_IRQn);
	NVIC_DisableIRQ(EUART0_RX_IRQn);
	NVIC_ClearPendingIRQ(EUART0_TX_IRQn);
	NVIC_DisableIRQ(EUART0_TX_IRQn);
	CMU_ClockEnable(cmuClock_EUART0, false);

	set_ir_tx_2_disabled();
	set_ir_rx_2_disabled();

	ir_uart_deinit = true;
}

/*********************************************************************
Function:       is_ir_UART_Enabled
Input:          void
Output:         uint32_t: 1 if RX enabled
Dependencies:
Description:
********************************************************************/
uint32_t is_ir_UART_Enabled( void )
{
	return ir_uart_deinit == false;
}

/*********************************************************************
Function:       is_ir_RX_Enabled
Input:          void
Output:         uint32_t: 1 if RX enabled
Dependencies:
Description:    Checks to see if RX is enabled
********************************************************************/
uint32_t is_ir_RX_Enabled( void )
{
	return (( EUART0->STATUS & _EUSART_STATUS_RXENS_MASK ) != 0 ? 1 : 0 );
}

/*********************************************************************
Function:       is_ir_TX_Enabled
Input:          void
Output:         uint32_t: 1 if TX enabled
Dependencies:
Description:    Checks to see if TX is enabled
********************************************************************/
uint32_t is_ir_TX_Enabled( void )
{
	if( ((EUART0->STATUS & _EUSART_STATUS_TXENS_MASK) > 0 ) &&
			((EUART0->STATUS & _EUSART_STATUS_TXTRI_MASK ) == 0 ))
	{
		return true;
	}
	return false;
}

/*********************************************************************
Function:       enable_ir_transmitter
Input:          void
Output:         void
Dependencies:
Description:    Enable UART transmitter
********************************************************************/
void enable_ir_transmitter(void)
{
	EUSART_IntClear(EUART0, EUSART_IEN_TXCIEN|EUSART_IF_TXIDLEIF);
	EUSART_IntEnable(EUART0, EUSART_IEN_TXCIEN);
	EUSART_TxTristateSet( EUART0, eusartTristateTxDisable );
}

/*********************************************************************
Function:       disable_ir_transmitter
Input:          void
Output:         void
Dependencies:
Description:    Disable UART transmitter
********************************************************************/
void disable_ir_transmitter(void)
{
	EUSART_IntDisable(EUART0, EUSART_IEN_TXCIEN);
	EUSART_TxTristateSet( EUART0, eusartTristateTxEnable );
}

/*********************************************************************
Function:       disable_ir_receiver
Input:          void
Output:         void
Dependencies:
Description:    disable UART receiver
********************************************************************/
void disable_ir_receiver(void)
{
	EUSART_IntDisable(EUART0, EUSART_IEN_RXFLIEN);
	EUSART_RxBlock( EUART0, eusartBlockRxEnable);
}

/*********************************************************************
Function:       enable_ir_receiver
Input:          void
Output:         void
Dependencies:
Description:    Enable UART receiver
********************************************************************/
void enable_ir_receiver(void)
{
	EUSART_IntClear(EUART0, EUSART_IEN_RXFLIEN);
	EUSART_IntEnable(EUART0, EUSART_IEN_RXFLIEN);
	EUSART_RxBlock( EUART0, eusartBlockRxDisable);
}

/*********************************************************************
Function:       transmitByteUART2
Input:          uint32_t byte: byte to transmit
Output:         void
Dependencies:
Description:    Send a byte
********************************************************************/
void IR_transmitByte(uint32_t byte)
{
	/* If transmitter is not enabled */
	if(0 == is_ir_TX_Enabled())
	{
		enable_ir_transmitter();
	}
	EUSART_Tx( EUART0, byte );
	EUSART_IntClear(EUART0, EUSART_IEN_TXCIEN|EUSART_IF_TXIDLEIF);
	EUSART_IntEnable(EUART0, EUSART_IEN_TXCIEN);
}

void EUART0_RX_IRQHandler(void)
{
	IR_DataByte_Received( (uint8_t)EUART0->RXDATA );
	// Clear the requesting interrupt before exiting the handler
	EUSART_IntClear(EUART0, EUSART_IF_RXFLIF);
}

void EUART0_TX_IRQHandler(void)
{
	/* EUSART_IntGetEnabled will return the flags set of only enabled int sources. It handles the masking internally */
	volatile uint32_t status = EUSART_IntGetEnabled( EUART0 );

	EUSART_IntClear(EUART0, EUSART_IEN_TXCIEN|EUSART_IF_TXIDLEIF);
	are_there_more_ir_bytes_to_send = 0;

	if( status & _EUSART_IF_TXIDLE_MASK )
	{
		EUSART_IntDisable(EUART0, EUSART_IEN_TXCIEN);
		EUSART_IntDisable(EUART0, EUSART_IF_TXIDLEIF);
		set_ir_tx_2_GPIO();			// <--- HMM
		set_ir_rx_2_UART();
		disable_ir_transmitter();
		enable_ir_receiver();
	}
	else
	{
		/* The application layer may or may not call hal_comms_transmit_byte_ir() while in the context of this function.
		 * If it does, then when we exit this function, are_there_more_ir_bytes_to_send will be set to 1.
		 */
		IR_TX_Complete();
		/* If are_there_more_ir_bytes_to_send was NOT set to 1, then we know the application layer does not intend to send any other bytes.
		 * Enable the Transmit Idle interrupt (similar to Transmit Complete for other processors) - as opposed to the Tx Register Empty interrupt.
		 * When the Transmit Idle interrupt then occurs, we will shut off the transmitter and enable the receiver.
		 */
		if(are_there_more_ir_bytes_to_send == 0)
		{
			/* no more to send, so enable Transmit Idle (Complete) interrupt */
			EUSART_IntClear(EUART0, EUSART_IF_TXIDLEIF);
			EUSART_IntEnable(EUART0, EUSART_IF_TXIDLEIF);
		}
	}
}
